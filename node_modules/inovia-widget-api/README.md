# inovia widget api

This is the basic widget API package which works together with the inovia dashboard API. From here each part of the system gets access to setting, onChangeSetting, receivedSignal and onSendSignal from the dashboard API.
Included in this package is common edit behavior together with widget composition.

From the API all subscribed components and the widget content itself will get the intl API injected.

All properties will be inherited from the parent.

## edit mode
When the dashboard API tells a widget via isEditMode to show the edit mode, the API will include a floating button in the lower right corner and a drawer. The drawer is triggered through the button.
All composed edit features end up in the order they were composed in the drawer together with a underneath Divider and a headline on top of it. The headline is the translated value based on the settings react component class name.

## helper function
The API offers a helper function which you should always use when adding new composable parts:
 - isReactComponent
To be applied when the contract requires a react component. See examples below.

## composition

to compose the widgets the API offers the following functions:
 - compose
 - join
 - setting
 - bottom
 - group

### compose

This function constructs the widget and puts all the composed parts together. In compose the intl API is injected into the component and all settings set into place. This function takes a two arguments. Each argument is an array of creators, a single creator or a React component. The first list is for the widget and the second list is for the settings.
The creators for the widget and the settings are applied on top of one another in the received order.

Creators should be sorted into settings, injectable, composed and widgetExtensions. Setting creators are explicitly to be used for settings. They are not compatible with widget creators. Widget creators are to be used to create a widget. WidgetExtensions visibly change the widget appearance. As example they add a pagination component to the bottom. Injectables are plain HoC that have logic. The result of the logic should be passed to the applied creator. Composed creators are functions that return a composed widget. They cannot be used in other creators. They are treated to be final.

#### creators
A creator is a function that takes options and returns a function that applies any combination of API functions (except compose). The inner function of a creator for the widget takes a widget as argument. The widget argument will be combined with the functionality the creator is to supply.
A simple creator that puts settings onto the widget looks like this:

```javascript
function filter() {
    return () => {
        return setting()(Settings);
    };
}
```

#### re-usable composed components (composed)

As stated earlier the composed functions are composed widgets. They can be re-used but not extended or used in other creators.

```javascript
export default function fullFeatureQueryWidget(Widget) {
    if(!isReactComponent(Widget))
        throw "fullFeatureQueryWidget: needs to have valid api object";

    return compose(
        [query(), pagination(), Widget], //widget itself
        [store(), page(), mapping(), filter()] //settings
    );
}
```


### join

The Join function is used to put two components into direct relation to one another. It takes three arguments. The first two arguments are the widgets to connect. The first one (higher order component; HOC) will be put on top of the second (React component; Widget).
The third parameter is a function mapStateToProps that allows the API to map state of the HOC to the widget.
mapState takes only one argument provided by the API which is the state of the HOC.
The result of that function will be de-constructed and each key=value will be mapped to the widgets components.
The result of the example below shows how this is done. The Widget parameter from doConnect when instantiated by react will get the property a injected which is read from state key b. The HoCs render method will be highjacked and overridden. They should not have any.

```javascript
function mapState(state) {
    return {
        a: state.b
    };
}

function doJoin(options) {
    return Widget => {
        if(!isReactComponent(Widget))
            throw "doJoin: needs to have valid api object";

        return join(Hoc, Widget);
    }
}
```

### setting

Settings puts a component into the settings section. The settings section is inside the drawer.
If multiple settings are applied they show up in the order from left to right as handed to compose.

```javascript
function applySettings(options) {
    return () => {
        return setting()(options);
    };
}
```

### bottom

Bottom wraps the Widget to allow controls into the lower part of the widget:

```html
<div className="widget-stretch-height">
    <Widget {...this.props} />
    <div className="widget-align-bottom">
        <Component {...this.props} />
    </div>
</div>
```

```javascript
function placeOnBottom(options) {
    return Widget => {
        if(!isApiObject(Widget))
            throw "pageable: needs to have valid api object";

        return bottom(Bottom, Widget);
    };
}
```

## group

Group is used in combination with injectable creators. Group takes unlimited arguments. The first two are like in join (the first and the third), a HOC and a mapping function. All parameters at the end are creators for SETTINGS. Group does not directly touch a Widget but rather the settings that a Widget is using. The contract is slightly different from a normal creator.

```javascript
function mapping(...composers) {
    return () => group(Mapping, mapStateToProps, ...composers);
}
```
