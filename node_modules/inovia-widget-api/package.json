{
  "_args": [
    [
      {
        "raw": "inovia-widget-api@^0.1.0",
        "scope": null,
        "escapedName": "inovia-widget-api",
        "name": "inovia-widget-api",
        "rawSpec": "^0.1.0",
        "spec": ">=0.1.0 <0.2.0",
        "type": "range"
      },
      "/home/esibern/Desktop/Hydra2"
    ]
  ],
  "_from": "inovia-widget-api@>=0.1.0 <0.2.0",
  "_id": "inovia-widget-api@0.1.0",
  "_inCache": true,
  "_location": "/inovia-widget-api",
  "_nodeVersion": "6.10.0",
  "_npmUser": {
    "name": "deployment",
    "email": "noreply@inovia.nu"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "inovia-widget-api@^0.1.0",
    "scope": null,
    "escapedName": "inovia-widget-api",
    "name": "inovia-widget-api",
    "rawSpec": "^0.1.0",
    "spec": ">=0.1.0 <0.2.0",
    "type": "range"
  },
  "_requiredBy": [
    "/",
    "/inovia-widget-extension-pagination",
    "/inovia-widget-extension-responsive",
    "/insight-widget-api",
    "/insight-widgets-echarts",
    "/insight-widgets-simple"
  ],
  "_resolved": "https://nexus.inoviagroup.se/content/groups/npm/inovia-widget-api/-/inovia-widget-api-0.1.0.tgz",
  "_shasum": "15770aea5002c8deae6b99966617961fcf3f3438",
  "_shrinkwrap": null,
  "_spec": "inovia-widget-api@^0.1.0",
  "_where": "/home/esibern/Desktop/Hydra2",
  "author": {
    "name": "Jonas Hartwig",
    "email": "jonas.hartwig@inoviagroup.se"
  },
  "bugs": {
    "url": "https://github.com/inovia-group/inovia-npm-packages/issues"
  },
  "dependencies": {
    "material-ui": "~0.16.4",
    "react": "^15.4.0",
    "react-dom": "^15.4.0",
    "react-intl": "~2.1.3"
  },
  "description": "Inovia widget api",
  "devDependencies": {
    "babel-cli": "^6.9.0",
    "babel-eslint": "^7.1.1",
    "babel-plugin-rewire": "^1.0.0",
    "babel-polyfill": "^6.16.0",
    "babel-preset-es2015": "^6.9.0",
    "babel-preset-react": "^6.16.0",
    "babel-preset-stage-1": "^6.5.0",
    "babelify": "^7.3.0",
    "browserify": "^13.1.0",
    "cross-env": "^3.1.3",
    "es6-promise-polyfill": "^1.2.0",
    "eslint": "^3.10.2",
    "eslint-plugin-react": "^6.7.1",
    "jasmine-core": "^2.5.2",
    "jasmine-promises": "^0.4.1",
    "karma": "^1.3.0",
    "karma-babel-preprocessor": "^6.0.1",
    "karma-browserify": "^5.1.0",
    "karma-chrome-launcher": "^2.0.0",
    "karma-intl-shim": "^1.0.3",
    "karma-jasmine": "^1.0.2",
    "karma-phantomjs-launcher": "^1.0.2",
    "karma-sinon": "^1.0.5",
    "node-sass": "^3.10.1",
    "phantomjs-polyfill-find": "^0.0.1",
    "phantomjs-polyfill-object-assign": "0.0.2",
    "pre-commit": "^1.1.3",
    "react-addons-test-utils": "^15.4.0",
    "react-dropzone": "^3.5.2",
    "recursive-uglifyjs": "^1.0.0",
    "rimraf": "^2.5.4",
    "sinon": "^1.17.6",
    "uglifyjs": "^2.4.10",
    "watchify": "^3.7.0"
  },
  "dist": {
    "shasum": "15770aea5002c8deae6b99966617961fcf3f3438",
    "tarball": "https://nexus.inoviagroup.se/content/groups/npm/inovia-widget-api/-/inovia-widget-api-0.1.0.tgz"
  },
  "homepage": "https://github.com/inovia-group/inovia-npm-packages#readme",
  "license": "Inovia AB",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "deployment",
      "email": "noreply@inovia.nu"
    }
  ],
  "name": "inovia-widget-api",
  "optionalDependencies": {},
  "pre-commit": [
    "test"
  ],
  "private": false,
  "readme": "# inovia widget api\n\nThis is the basic widget API package which works together with the inovia dashboard API. From here each part of the system gets access to setting, onChangeSetting, receivedSignal and onSendSignal from the dashboard API.\nIncluded in this package is common edit behavior together with widget composition.\n\nFrom the API all subscribed components and the widget content itself will get the intl API injected.\n\nAll properties will be inherited from the parent.\n\n## edit mode\nWhen the dashboard API tells a widget via isEditMode to show the edit mode, the API will include a floating button in the lower right corner and a drawer. The drawer is triggered through the button.\nAll composed edit features end up in the order they were composed in the drawer together with a underneath Divider and a headline on top of it. The headline is the translated value based on the settings react component class name.\n\n## helper function\nThe API offers a helper function which you should always use when adding new composable parts:\n - isReactComponent\nTo be applied when the contract requires a react component. See examples below.\n\n## composition\n\nto compose the widgets the API offers the following functions:\n - compose\n - join\n - setting\n - bottom\n - group\n\n### compose\n\nThis function constructs the widget and puts all the composed parts together. In compose the intl API is injected into the component and all settings set into place. This function takes a two arguments. Each argument is an array of creators, a single creator or a React component. The first list is for the widget and the second list is for the settings.\nThe creators for the widget and the settings are applied on top of one another in the received order.\n\nCreators should be sorted into settings, injectable, composed and widgetExtensions. Setting creators are explicitly to be used for settings. They are not compatible with widget creators. Widget creators are to be used to create a widget. WidgetExtensions visibly change the widget appearance. As example they add a pagination component to the bottom. Injectables are plain HoC that have logic. The result of the logic should be passed to the applied creator. Composed creators are functions that return a composed widget. They cannot be used in other creators. They are treated to be final.\n\n#### creators\nA creator is a function that takes options and returns a function that applies any combination of API functions (except compose). The inner function of a creator for the widget takes a widget as argument. The widget argument will be combined with the functionality the creator is to supply.\nA simple creator that puts settings onto the widget looks like this:\n\n```javascript\nfunction filter() {\n    return () => {\n        return setting()(Settings);\n    };\n}\n```\n\n#### re-usable composed components (composed)\n\nAs stated earlier the composed functions are composed widgets. They can be re-used but not extended or used in other creators.\n\n```javascript\nexport default function fullFeatureQueryWidget(Widget) {\n    if(!isReactComponent(Widget))\n        throw \"fullFeatureQueryWidget: needs to have valid api object\";\n\n    return compose(\n        [query(), pagination(), Widget], //widget itself\n        [store(), page(), mapping(), filter()] //settings\n    );\n}\n```\n\n\n### join\n\nThe Join function is used to put two components into direct relation to one another. It takes three arguments. The first two arguments are the widgets to connect. The first one (higher order component; HOC) will be put on top of the second (React component; Widget).\nThe third parameter is a function mapStateToProps that allows the API to map state of the HOC to the widget.\nmapState takes only one argument provided by the API which is the state of the HOC.\nThe result of that function will be de-constructed and each key=value will be mapped to the widgets components.\nThe result of the example below shows how this is done. The Widget parameter from doConnect when instantiated by react will get the property a injected which is read from state key b. The HoCs render method will be highjacked and overridden. They should not have any.\n\n```javascript\nfunction mapState(state) {\n    return {\n        a: state.b\n    };\n}\n\nfunction doJoin(options) {\n    return Widget => {\n        if(!isReactComponent(Widget))\n            throw \"doJoin: needs to have valid api object\";\n\n        return join(Hoc, Widget);\n    }\n}\n```\n\n### setting\n\nSettings puts a component into the settings section. The settings section is inside the drawer.\nIf multiple settings are applied they show up in the order from left to right as handed to compose.\n\n```javascript\nfunction applySettings(options) {\n    return () => {\n        return setting()(options);\n    };\n}\n```\n\n### bottom\n\nBottom wraps the Widget to allow controls into the lower part of the widget:\n\n```html\n<div className=\"widget-stretch-height\">\n    <Widget {...this.props} />\n    <div className=\"widget-align-bottom\">\n        <Component {...this.props} />\n    </div>\n</div>\n```\n\n```javascript\nfunction placeOnBottom(options) {\n    return Widget => {\n        if(!isApiObject(Widget))\n            throw \"pageable: needs to have valid api object\";\n\n        return bottom(Bottom, Widget);\n    };\n}\n```\n\n## group\n\nGroup is used in combination with injectable creators. Group takes unlimited arguments. The first two are like in join (the first and the third), a HOC and a mapping function. All parameters at the end are creators for SETTINGS. Group does not directly touch a Widget but rather the settings that a Widget is using. The contract is slightly different from a normal creator.\n\n```javascript\nfunction mapping(...composers) {\n    return () => group(Mapping, mapStateToProps, ...composers);\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/inovia-group/inovia-npm-packages.git"
  },
  "scripts": {
    "build": "npm run build:js && npm run build:sass",
    "build:js": "eslint src && babel src --out-dir dist",
    "build:sass": "node-sass -r -x --output-style compressed --include-path node_modules src/styles.scss dist/styles.css",
    "dev": "nodemon --watch src --exec npm run build",
    "prepublish": "npm run test && rimraf dist && mkdir dist && npm run build && npm run uglify",
    "test": "cross-env NODE_ENV=test karma start test/karma.conf.js",
    "test:dev": "cross-env NODE_ENV=test karma start test/karma.dev.conf.js",
    "uglify": "recursive-uglifyjs dist"
  },
  "version": "0.1.0"
}
