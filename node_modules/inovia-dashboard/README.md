# inovia dashboard

Our dashboard implementation reusable.

BREAKING CHANGES:
1.0.11: styles now go into dist/styles.css

using the reducer:

```javascript
import { combineReducers } from "redux";
import { routerReducer } from "react-router-redux";
import { reducer as dashboard } from "inovia-dashboard";

export default combineReducers({
    dashboard,

    routing: routerReducer
});
```

using the view and actions:

```javascript
import React from "react";
import ReactDOM from "react-dom";
import { view as Dashboard, actions as DashboardActions } from "inovia-dashboard";
import { SomeWidget, SomeOtherWidget } from "../myWidgets";

const widgetMappings = {
    "type.a": SomeWidget,
    "type.b": SomeOtherWidget
};

class MyComponent extends React.Component {
    _editWidget(widgetIndex) {}

    _viewWidget(widgetIndex) {}

    componentDidMount() {
        const { dispatch } = this.props,
            dashboard = {
                layout: {
                    lg: [{"x": 0, "y": 0, "w": 6, "h": 3, "i": "widget.type.a"}]
                    sm: [{"x": 0, "y": 0, "w": 6, "h": 3, "i": "widget.type.a"}]
                    md: [{"x": 0, "y": 0, "w": 6, "h": 3, "i": "widget.type.a"}]
                },
                widgets: [{
                    id: "widget.type.a",
                    type: "type.a",
                    settings: {
                    }
                }]
            };
        dispatch(DashboardActions.replace(dashboard));
    }

    render() {

        return (
            <Dashboard dashboard={dashboard} widgetMappings={widgetMappings} editWidget={this._editWidget} viewWidget={this._viewWidget} />
        );
    }
}
```

as an alternative to sending the dashboard in "manually" the dashboard view can be wrapped into redux as well. This way the store can be connected to the view.

```javascript
import { connect } from "react-redux";
import Dashboard from “inovia-dashboard”;

const DashboardConnectedToStore = connect(store => {
    return {
        dashboard: store.this.is.my.dashboard
    };
})(Dashboard);
```

if viewWidget or editWidget are undefined the corresponding buttons are not shown. Of course the Dashboard view component can be used without the reducer. but then one would need to build the Immutable structure manually. All records can be found like this:

```javascript
import { WidgetRecord, LayoutItemRecord, LayoutRecord, DashboardRecord } from "inovia-dashboard";
```

actions:

```javascript
cloneWidget(index)
// deletes the widget from server, returns promise
deleteDashboard(dashboardId)
close()
// dashboard, object representation of dashboard. the current state will completely be replaced
replace(dashboard)
updateLayout(layout)
// dashboard is an optional object representing a dashboard. If given there will be no server call to load id.
open(id, dashboard)
toggleIsPublic()
// isSaveAs [true|false], if set dashboard id will be removed and a new dashboard will be created
// returns promise
save(dashboard, isSaveAs)
// type, string given a type. must exist in widgetMappgings
// settings, object, an arbitrary description about the widget. Not mandatory
addWidget(type, settings)
deleteWidget(id)
// widget, widget object
replaceWidget(index, widget)
// groups: "ALL" or an array of groups to send the signal to. where [] is the default group, signal, any arbitrary object with type property
sendSignalExternal(groups, signal)
// signal, any arbitrary object with type property
sendSignal(widgetId, signal)
// setting, any arbitrary object
setSetting(widgetId, setting)
// removes all layout and widgets
resetAllWidgets()
```

each widget gets the following properties from the dashboard:

    1. settings: the settings object for the widget. to be set by setSetting(object)
    2. receivedSignal: the signal object received from any widget of the same group. to be sent using sendSignal(object)
    3. sendSignal: the function for sending signals. it gets called with the new signal object as parameter
    4. setSetting: the function for updating the settings. it gets called with the new setting object as parameter
    5. goToDetailEditView: a function to indicate the widget internally wants to expose its edit view
    6. goToDetailView: a function to indicate the widget internally wants to expose the detail view

## Signals

signals can have arbitrary content. However type and source are reserved for internal usage. So you would be advised to not have any naming related issues to have the single content as a separate property. Source will be set as the id of the widget where the signal originates. Type is a attribute to distinguish certain scope. A widget implementation decides which types it should "listen" to. Internally this:

```javascript
{
    mySignalContent: {
        x: "Y?"
    }
}
```

will become this:

```javascript
{
    source: "WidgetId",
    type: "some defined type"
    mySignalContent: {
        x: "Y?"
    }
}
```

to do:
provide common "setup your widget" if settings is empty
provide better layout handling on adding widget
