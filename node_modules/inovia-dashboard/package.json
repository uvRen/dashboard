{
  "_args": [
    [
      {
        "raw": "inovia-dashboard@^3.0.0",
        "scope": null,
        "escapedName": "inovia-dashboard",
        "name": "inovia-dashboard",
        "rawSpec": "^3.0.0",
        "spec": ">=3.0.0 <4.0.0",
        "type": "range"
      },
      "/home/esibern/Desktop/Hydra2"
    ]
  ],
  "_from": "inovia-dashboard@>=3.0.0 <4.0.0",
  "_id": "inovia-dashboard@3.0.0",
  "_inCache": true,
  "_location": "/inovia-dashboard",
  "_nodeVersion": "6.10.0",
  "_npmUser": {
    "name": "deployment",
    "email": "noreply@inovia.nu"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "inovia-dashboard@^3.0.0",
    "scope": null,
    "escapedName": "inovia-dashboard",
    "name": "inovia-dashboard",
    "rawSpec": "^3.0.0",
    "spec": ">=3.0.0 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://nexus.inoviagroup.se/content/groups/npm/inovia-dashboard/-/inovia-dashboard-3.0.0.tgz",
  "_shasum": "9faec07e5438af53cb0e67ec5624b2768be18472",
  "_shrinkwrap": null,
  "_spec": "inovia-dashboard@^3.0.0",
  "_where": "/home/esibern/Desktop/Hydra2",
  "author": {
    "name": "Jonas Hartwig",
    "email": "jonas.hartwig@inoviagroup.se"
  },
  "bugs": {
    "url": "https://github.com/inovia-group/inovia-npm-packages/issues"
  },
  "dependencies": {
    "immutable": "~3.8.1",
    "material-ui": "~0.16.4",
    "react": "^15.4.0",
    "react-addons-pure-render-mixin": "^15.4.0",
    "react-dom": "^15.4.0",
    "react-grid-layout": "~0.13.9",
    "react-redux": "~4.4.5",
    "redux": "~3.6.0",
    "uuid": "~2.0.3"
  },
  "description": "Dashboard api based on redux",
  "devDependencies": {
    "babel-cli": "^6.9.0",
    "babel-eslint": "^7.1.1",
    "babel-plugin-rewire": "^1.0.0",
    "babel-preset-es2015": "^6.9.0",
    "babel-preset-react": "^6.16.0",
    "babel-preset-stage-1": "^6.5.0",
    "babelify": "^7.3.0",
    "browserify": "^13.1.0",
    "cross-env": "^3.1.3",
    "eslint": "^3.10.2",
    "eslint-plugin-react": "^6.7.1",
    "jasmine-core": "^2.5.2",
    "jasmine-promises": "^0.4.1",
    "karma": "^1.3.0",
    "karma-babel-preprocessor": "^6.0.1",
    "karma-browserify": "^5.1.0",
    "karma-chrome-launcher": "^2.0.0",
    "karma-jasmine": "^1.0.2",
    "karma-phantomjs-launcher": "^1.0.2",
    "karma-sinon": "^1.0.5",
    "node-sass": "^3.10.1",
    "phantomjs-polyfill-find": "^0.0.1",
    "phantomjs-polyfill-object-assign": "0.0.2",
    "pre-commit": "^1.1.3",
    "promise-polyfill": "^6.0.2",
    "react-addons-test-utils": "^15.4.0",
    "react-tap-event-plugin": "^2.0.1",
    "recursive-uglifyjs": "^1.0.0",
    "redux-thunk": "^2.1.0",
    "rimraf": "^2.5.4",
    "sinon": "^1.17.6",
    "uglifyjs": "^2.4.10",
    "watchify": "^3.7.0"
  },
  "dist": {
    "shasum": "9faec07e5438af53cb0e67ec5624b2768be18472",
    "tarball": "https://nexus.inoviagroup.se/content/groups/npm/inovia-dashboard/-/inovia-dashboard-3.0.0.tgz"
  },
  "homepage": "https://github.com/inovia-group/inovia-npm-packages#readme",
  "license": "Inovia AB",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "deployment",
      "email": "noreply@inovia.nu"
    }
  ],
  "name": "inovia-dashboard",
  "optionalDependencies": {},
  "pre-commit": [
    "test"
  ],
  "private": false,
  "readme": "# inovia dashboard\n\nOur dashboard implementation reusable.\n\nBREAKING CHANGES:\n1.0.11: styles now go into dist/styles.css\n\nusing the reducer:\n\n```javascript\nimport { combineReducers } from \"redux\";\nimport { routerReducer } from \"react-router-redux\";\nimport { reducer as dashboard } from \"inovia-dashboard\";\n\nexport default combineReducers({\n    dashboard,\n\n    routing: routerReducer\n});\n```\n\nusing the view and actions:\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { view as Dashboard, actions as DashboardActions } from \"inovia-dashboard\";\nimport { SomeWidget, SomeOtherWidget } from \"../myWidgets\";\n\nconst widgetMappings = {\n    \"type.a\": SomeWidget,\n    \"type.b\": SomeOtherWidget\n};\n\nclass MyComponent extends React.Component {\n    _editWidget(widgetIndex) {}\n\n    _viewWidget(widgetIndex) {}\n\n    componentDidMount() {\n        const { dispatch } = this.props,\n            dashboard = {\n                layout: {\n                    lg: [{\"x\": 0, \"y\": 0, \"w\": 6, \"h\": 3, \"i\": \"widget.type.a\"}]\n                    sm: [{\"x\": 0, \"y\": 0, \"w\": 6, \"h\": 3, \"i\": \"widget.type.a\"}]\n                    md: [{\"x\": 0, \"y\": 0, \"w\": 6, \"h\": 3, \"i\": \"widget.type.a\"}]\n                },\n                widgets: [{\n                    id: \"widget.type.a\",\n                    type: \"type.a\",\n                    settings: {\n                    }\n                }]\n            };\n        dispatch(DashboardActions.replace(dashboard));\n    }\n\n    render() {\n\n        return (\n            <Dashboard dashboard={dashboard} widgetMappings={widgetMappings} editWidget={this._editWidget} viewWidget={this._viewWidget} />\n        );\n    }\n}\n```\n\nas an alternative to sending the dashboard in \"manually\" the dashboard view can be wrapped into redux as well. This way the store can be connected to the view.\n\n```javascript\nimport { connect } from \"react-redux\";\nimport Dashboard from “inovia-dashboard”;\n\nconst DashboardConnectedToStore = connect(store => {\n    return {\n        dashboard: store.this.is.my.dashboard\n    };\n})(Dashboard);\n```\n\nif viewWidget or editWidget are undefined the corresponding buttons are not shown. Of course the Dashboard view component can be used without the reducer. but then one would need to build the Immutable structure manually. All records can be found like this:\n\n```javascript\nimport { WidgetRecord, LayoutItemRecord, LayoutRecord, DashboardRecord } from \"inovia-dashboard\";\n```\n\nactions:\n\n```javascript\ncloneWidget(index)\n// deletes the widget from server, returns promise\ndeleteDashboard(dashboardId)\nclose()\n// dashboard, object representation of dashboard. the current state will completely be replaced\nreplace(dashboard)\nupdateLayout(layout)\n// dashboard is an optional object representing a dashboard. If given there will be no server call to load id.\nopen(id, dashboard)\ntoggleIsPublic()\n// isSaveAs [true|false], if set dashboard id will be removed and a new dashboard will be created\n// returns promise\nsave(dashboard, isSaveAs)\n// type, string given a type. must exist in widgetMappgings\n// settings, object, an arbitrary description about the widget. Not mandatory\naddWidget(type, settings)\ndeleteWidget(id)\n// widget, widget object\nreplaceWidget(index, widget)\n// groups: \"ALL\" or an array of groups to send the signal to. where [] is the default group, signal, any arbitrary object with type property\nsendSignalExternal(groups, signal)\n// signal, any arbitrary object with type property\nsendSignal(widgetId, signal)\n// setting, any arbitrary object\nsetSetting(widgetId, setting)\n// removes all layout and widgets\nresetAllWidgets()\n```\n\neach widget gets the following properties from the dashboard:\n\n    1. settings: the settings object for the widget. to be set by setSetting(object)\n    2. receivedSignal: the signal object received from any widget of the same group. to be sent using sendSignal(object)\n    3. sendSignal: the function for sending signals. it gets called with the new signal object as parameter\n    4. setSetting: the function for updating the settings. it gets called with the new setting object as parameter\n    5. goToDetailEditView: a function to indicate the widget internally wants to expose its edit view\n    6. goToDetailView: a function to indicate the widget internally wants to expose the detail view\n\n## Signals\n\nsignals can have arbitrary content. However type and source are reserved for internal usage. So you would be advised to not have any naming related issues to have the single content as a separate property. Source will be set as the id of the widget where the signal originates. Type is a attribute to distinguish certain scope. A widget implementation decides which types it should \"listen\" to. Internally this:\n\n```javascript\n{\n    mySignalContent: {\n        x: \"Y?\"\n    }\n}\n```\n\nwill become this:\n\n```javascript\n{\n    source: \"WidgetId\",\n    type: \"some defined type\"\n    mySignalContent: {\n        x: \"Y?\"\n    }\n}\n```\n\nto do:\nprovide common \"setup your widget\" if settings is empty\nprovide better layout handling on adding widget\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/inovia-group/inovia-npm-packages.git"
  },
  "scripts": {
    "build": "npm run build:js && npm run build:sass",
    "build:js": "eslint src && babel src --out-dir dist",
    "build:sass": "node-sass -r -x --output-style compressed --include-path node_modules src/styles.scss dist/styles.css",
    "dev": "nodemon --watch src --exec npm run build",
    "prepublish": "npm run test && rimraf dist && mkdir dist && npm run build && npm run uglify",
    "test": "cross-env NODE_ENV=test karma start test/karma.conf.js",
    "test:dev": "cross-env NODE_ENV=test karma start test/karma.dev.conf.js",
    "uglify": "recursive-uglifyjs dist"
  },
  "version": "3.0.0"
}
